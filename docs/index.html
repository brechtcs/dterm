<!doctype html>
<html><head>
    <title>dterm</title>
    <meta charset="utf-8">

	<link rel="stylesheet" href="dat://dfurl.hashbase.io/vendor/water-light-v1.4.0.css">
</head>
<body>
    <main id="dterm-docs" contenteditable="false"><h1>dterm</h1><p>Distributed Terminal.</p><h2>Introducing dterm</h2><p>As the heir to <a href="https://webterm.hashbase.io/README.md">Webterm</a>, dterm has inherited most of its high-level goals. These are best articulated in Paul Frazee's introduction post <a href="https://pfrazee.hashbase.io/blog/reimagining-the-browser-as-a-network-os">"Reimagining the browser as a network OS"</a>. It explains how using the dat protocol as the foundation for a distributed web has opened doors that were firmly closed for legacy web browsers.</p><blockquote><p>Dat is, effectively, a Wide-Area Network Filesystem. It uses p2p swarming to distribute file updates, content-hashing to ensure integrity, and keypair signatures to assure authorship.</p></blockquote><p>This means that applications using the dat protocol in <a href="https://beakerbrowser.com">Beaker</a> can mimic – enhance even – the behaviour of traditional desktop programs. Enhance because dat can solve difficult problems like data synchronisation and publication out-of-the-box. Therein lies the true power of the "Network OS". You get the same old reliable and familiar workflows from the desktop, but they're instantly shareable without the need for expensive cloud storage or complicated client-server setups. At least in theory.</p><p>In practice though we need to recreate a whole bunch of applications before we'll be able to match the power and usability of existing desktop ecosystems. A good place to start is the low-level power tool that's essential to any operating system: the terminal emulator. This was the main motivation behind Webterm; the goal of dterm is to continue its progress.</p><p>There are some differences between the current version of dterm and the original Webterm specifications. Some are intentional divergences, others are missing features that are still on the roadmap. Here's a basic overview:</p><ul><li><strong>Divergence:</strong> In the Webterm spec commands were defined using the <code>main</code> function in a plain Javascript file. In dterm ES modules are used, with the <code>export default</code> function being the main command.</li><li><strong>Divergence:</strong> The original Webterm implementation used a URL scheme where the hash contained the working directory. In dterm changes this to <code>dat://dterm.hashbase.io/&lt;dat-key&gt;/path/to/dir</code>. This change should make it easier to build applications using the same URL scheme, such as <a href="https://dcode.hashbase.io/docs">dcode</a>.</li><li><strong>Planned divergence:</strong> The Webterm spec proposes a <code>terminal</code> API to provide interactivity. Some kind of solution for this use case will be included in dterm, but is likely to differ significantly from the proposed implementation in the Webterm spec.</li><li><strong>Planned:</strong> The Webterm spec proposes a syntax for command sub-invocations. The intention is to try and support this syntax in dterm, though implementation details may still change.</li><li><strong>Planned: </strong>All the Network OS superpowers proposed in Paul Frazee's blog post – like the User Root FS with symlinks and shared secret folders – are still missing. These features will probably require some coordination with Beaker development, and will be added accordingly.</li><li><strong>Planned:</strong> The security model of the Webterm spec stated that commands would &nbsp;be executed in their own context away from the main terminal window. This will be achieved in dterm using a sandboxed iframe. Until this features lands, it's not advised to use dterm for sensitive tasks!</li></ul><h2>Getting started</h2><p><a href="dat://dterm.hashbase.io">Opening dterm</a>, you will be asked to select a dat archive as your working directory. Alternatively, you can create a new archive. For the purpose of this tutorial, let's go with that option. We'll use this new dat to create our first custom command.&nbsp;</p><p>To write our own custom commands, we'll need a text editor. One option that's specifically designed to work well with dterm is dcode. You can follow <a href="https://dcode.hashbase.io/docs">these instructions</a> to install it. When installing commands like this, you can use them in any dat archive. The custom command we're going to create however, will only be available locally in our new archive. To do this, we start by creating a <code>commands</code> folder in the archive root.&nbsp;</p><pre class="cs">&gt; mdkir commands</pre><p>We create custom commands by writing Javascript files in this folder, like so:</p><pre class="javascript">// commands/hello-world.js<br><br>export default function () {<br>  return 'Hello, world!'<br>}</pre><p>As you see, our command is a basic ES module file. When invoked, dterm will execute the default export. As mentioned before, this commands is by default only available locally inside its own dat archive. To make it available anywhere, you can use <code>term install</code>.</p><pre class="nohighlight">&gt; hello-world<br>Hello, world!<br><br>&gt; term install commands/hello-world.js<br><br>&gt; cd dat://dterm.hashbase.io<br><br>&gt; hello-world<br>Hello, world!</pre><p>Of course you'll want to go further than a simple "Hello World". In the next section we'll introduce some more advanced features you can use to create custom commands.</p><h2>Advanced commands</h2><h3>Arguments</h3><p>All command modules export a default function which accepts an options object and positional arguments, and returns a JS value or object. Here's an example which echos the arguments:</p><pre class="javascript">// echo.js<br>export default function (opts, ...args) {<br>  return JSON.stringify(opts) + args.join(' ')<br>}</pre><p>Invocation:</p><pre class="nohighlight">&gt; echo -abc --hello world this is my echo<br>{"a": true, "b": true, "c": true, "hello": "world"} this is my echo</pre><h3>Subcommands</h3><p>All non-default exports on a command module can be accessed as subcommands. This is a help function for the above <code>echo</code> example:</p><pre class="javascript">// echo.js<br>export function help () {<br>  return 'echo &lt;opts&gt; [...args]'<br>}</pre><p><br>Invocation:</p><pre class="nohighlight">&gt; echo help<br>echo &lt;opts&gt; [...args]</pre><h3>Async</h3><p>Commands can be asynchronous. The terminal will be blocked until the async function returns. For example, a naive <code>curl</code> implementation could look like this:</p><pre class="javascript">// curl.js<br>export default async function (opts, url) {<br>  var res = await fetch(url)<br>  return res.text()<br>}</pre><p>Generators and iterators are also supported. These will be rendered item-per-item as streams. Take for example this basic <code>cat</code> command:</p><pre class="javascript">// cat.js<br>export default async function* (opts, ...files) {<br>  for await (let file of files) {<br>    var url = new URL(file)<br>    var dat = new DatArchive(url.origin)<br>    yield dat.readFile(file)<br>  }<br>}</pre><h3>Rendering</h3><p>The command may specify a <code>toHTML</code> function on the response object. This method will be invoked if/when the output is rendered to the cli.</p><pre class="javascript">// hello-big-world.js<br>export default function () {<br>  return {<br>    toHTML: () =&gt; '&lt;h1&gt;HELLO WORLD!&lt;/h1&gt;'<br>  }<br>}</pre><p>Errors don't need any specific rendering logic. Any <code>Error</code> instances returned (or yielded) by the command will be rendered as errors in the terminal.</p><pre class="javascript">export default function (opts, file) {<br>  try {<br>    return await archive.readFile(file)<br>  } catch (err) {<br>    return err<br>  }<br>}</pre><h2>License</h2><p>AGPL-v3.0</p></main>
</body></html>